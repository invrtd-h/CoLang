# CoLang

![](img/CoLang.png)

CoLang(코언어)은 **코글**에서 개발한 프로그래밍 언어다 맨이야.

### 예제

#### 팩토리얼 계산하기 (재귀함수)

```scala
import mte._
import scala.language.postfixOps

def 팩토리얼(): Unit = {
  춘잣! (
    "팩토리얼" 중에는!! 아무리 "뭉"이라도 (
      (유링게슝한?) ("뭉" 돈 탱 원에??) (
        "팩토리얼"아 ("뭉" 코 뭉) 먹어라?? 조이고 "뭉"
      ) 안유링게슝 뭉
    ) 할 수가 없단다!!,
    정품 맞어 (
      "팩토리얼"아 1 먹어라?? 코 1 꼽표~~, // 1! == 1
      "팩토리얼"아 4 먹어라?? 코 24 꼽표~~, // 4! == 24
      "팩토리얼"아 8 먹어라?? 코 40320 꼽표~~ // 8! == 40320
    )
  )
}
```

#### 에라토스테네스의 체

```scala
import mte._
import scala.language.postfixOps

def test6(): Unit = {
  춘잣! (
    아니세상에 자기가 "케인님 코 크기" 라는사람인데 3100 를 했대,
    아니세상에 자기가 "에라토스테네스" 라는사람인데 왕한줄서기("케인님 코 크기", 뭉) 발행 NFT 를 했대,
    "에라토스테네스" 게 그런 사람이 ("에라토스테네스" 갖고와 탱 할게 한판마안~~!! 탱) 힐 순없는지,
    "에라토스테네스" 게 그런 사람이 ("에라토스테네스" 갖고와 뭉 할게 한판마안~~!! 탱) 힐 순없는지,
    (뭉탱 달려가 "케인님 코 크기") ("뭉") (
      아니세상에 자기가 "탱" 이라는사람인데 "뭉" 발행 NFT 를 했대,
      강제연결 ("뭉" 조이고 "탱" 돈 "케인님 코 크기" 원에=?? 꼽표~~) (
        "에라토스테네스" 게 그런 사람이 ("에라토스테네스" 갖고와 ("뭉" 화면을 확대하셨군요!! "탱") 할게 한판마안~~!! 탱) 힐 순없는지,
        "탱" 게 그런 사람이 ("탱" 배 뭉) 힐 순없는지
      )
    ),
    (탱 달려가 "케인님 코 크기") ("뭉") {
      (유링게슝한?) ("에라토스테네스" 갖고와 임마!! "뭉") {
        "뭉" 리액션 "%s\t"
      } 안유링게슝 스키비야
    },
    스키비야 리액션 "\n"
  )
}
```

#### 객체 지향 프로그래밍으로 복소수 구현하기

```scala
import mte._
import scala.language.postfixOps

def test10(): Unit = {
  춘잣! (
    "복소수" 하는 플레이보이 예전에 ("실수부", "허수부") 하더놈 같은데 이제 (
      "덧셈" 중에는!! 아무리 "우변"이라도 (
        "복소수"야 (
          나 의 "실수부" 감동님 사랑해 배 ("우변"의 "실수부" 감동님 사랑해),
          나 의 "허수부" 감동님 사랑해 배 ("우변"의 "허수부" 감동님 사랑해)
        ) 먹어라??
      ) 할 수가 없단다!!
    ) 하는갑지 돈좀버냐?? 개노잼 노라라??,
    아니세상에 자기가 "x" 라는사람인데 ("복소수"야 (1, 2) 먹어라??) 를 했대,
    아니세상에 자기가 "y" 라는사람인데 ("복소수"야 (7, 5) 먹어라??) 를 했대,
    "x" 의 "덧셈" 감동님 사랑해 야 "y" 먹어라?? 리액션 "%s\n"
  )
}

```

## 자료형

* 일급 자료형
  * 스키비야
  * 유리계수
  * ~~제가 정리한~~ 글
  * 함수
  * 한줄서기
  * 뭉탱이
  * 코객체
* 일급이 아닌 자료형
  * NFT
  * 코괴물

### 일급 자료형

#### 스키비야

C에서 void라는 게 있잖아요 그런데 우리가 C한테 져서는 안 되잖아?? 그래서 **스키비야**라는 
키워드를 준비를 했어요~ **스킵이야**라고 쓰는 것도 가능하단다.

#### 유리계수
분모가 1인 모든 유리계수 를! 사용할 수 있단다. ~~아아아이 그냥 정수라고 하면 되는 걸 그냥!~~

#### ~~부동소수~~
~~부동소수 그딴 게 어딨어 임마! 그런 거 함부로 쓰면 오차도 많고 별로 좋지도 아네.~~

#### 글

그냥 string이에요~ 얘 뭐 더 설명이 필요하니??

#### 함수

함수도 하나의 객체란다!

#### 한줄서기
어우 뭔 느낌인지 알죠? 지금처럼 이케 잘 돼 있어 버정 이렇게 있으면 딱 이렇게
해 가지고 vector 앞에. vector 앞에. 쯥. 그냥 한줄서기로 있단 말야 그래서 내가 만약에 n번째로 들어온 원소다
그러면 그냥 n번째 원소에 접근하면 되거든?? 근데 걔는

![m](img/he-does-like-this.png)

이러면서 한다??

#### 뭉탱이
어우 뭔 느낌인지 알죠? 지금처럼 이케 잘 돼 있지 않아 딱 한줄서기 그런 게 아니고 hashMap
앞에. hashMap 앞에. 쯥. 그냥 뭉탱이로 있단 말이야 그러면 hashKey 눈치를 봐야
해 이케 Key("44번 버스")가 온다 그러면은? 

![m](img/he-does-like-this.png)

이러면서 한다??

#### 코객체

**코객체**는 사용자가 직접 정의한 코괴물을 타입으로 갖는 객체다 맨이야. 
코객체를 써서 CoLang에서 객체 지향 프로그래밍을 구현할 수 있어요~

### 일급이 아닌 자료형

#### NFT

기본적으로 모든 값은 **불변**(const)이에요~ 불변 변수를 갖고 프로그래밍하는 게 요즘 트렌드다 
맨이야. 근데 불변 변수만 갖고 프로그래밍하는 건 좀 힘들잖어 그치? 그래서 C의 동적 할당
포인터 비슷하게 **NFT**라는 걸 준비를 했어요. NFT 를! 발급하면, NFT 자체는 불변이지만
NFT가 가리키는 변수는 바뀔 수 있어서 가변 변수가 된다 맨이야.

NFT 자료형은 한 가지 경우를 제외하고는 항상 그 **NFT가 가리키는 값**으로 decay 되게 되어
있어요~~ 그 경우가 뭐냐면 NFT 자료형인 변수를 수정할 때다맨.

#### 코괴물

코객체를 사용하기 위해서는 먼저 코괴물 를! 먼저 정의해야 한단다. 코괴물은 모두 생성자
하나씩을 갖고 있어서 생성자가 코객체 를! 만들어준다맨. 하지만 타입이라는 건~ 안전한
프로그래밍을 위해서 존재하는 것이기 때문에~ 쓸데없이 많은 자유도를 주지 않기로 했어요.
그래서 코괴물을 1급 객체로 쓸 수는 없다맨. 대신 코괴물의 이름 를! 부르면 
**생성자(constructor)와 같은 역할을 하는 함수**로 decay 된다 맨이야.

## 문법

#### 변수 를! 만든 나
```scala
import mte._
import scala.language.postfixOps

// 변수 "뭉"에 1 대입
아니세상에 자기가 "뭉" 이라는사람인데 1 를 했대

// 값 1을 가리키는 NFT를 발행하고 그 NFT를 "탱"에 대입
아니세상에 자기가 "탱" 이라는사람인데 1 발행 NFT 를 했대

// 이미 정의된 NFT "탱"이 가리키는 주소에 2 대입
"탱" 게 그런 사람이 2 힐 순없는지
```

#### 함수 를! 만든 나
```scala
import mte._
import scala.language.postfixOps

// 이름을 가진 함수 정의
"2배" 중에는!! 아무리 "뭉"이라도 ("뭉" 조이고 2) 할 수가 없단다!!

// 익명 함수 정의 후 변수에 대입
아니세상에 자기가 "2배" 라는사람인데 (
  "뭉"은 ("뭉" 조이고 2)다 게이조이고
)를 했대

// 변수 이름도 익명으로 하고 싶다면 아이고난 함수 사용
아니세상에 자기가 "2배" 라는사람인데 아이고난!!(아이고난1 조이고 2)를 했대
```

#### 기본적인 연산 를! 하는 나
```scala
import mte._
import scala.language.postfixOps

"뭉" 배 "탱" // +
"뭉" 코 "탱" // -
"뭉" 조이고 "탱" // *
"뭉" 법회 "탱" // /
"뭉" 코가커요 "탱" // %
"뭉" 꼽표~~ // ! (logical not)
"뭉" 돈 "탱" 원에?? // >
"뭉" 돈 "탱" 원에=?? // >=
"케인"아 "영양제" 먹어라?? // 함수 "케인"에 변수 "영양제"를 대입
(유링게슝한?) ("뭉") ("탱") 안유링게슝 "이" // 3항 연산자 뭉 ? 탱 : 이 (if 구현)
```

#### 한줄서기 를! 만든 나
혹시 모를까 봐 얘기하는 거지만 **한줄서기**는 C++의 vector나 Python의 list랑 비슷한
친구예요. 근데 이제 C++이나 Python보다 나아진 부분이 뭐냐면, 얘는 스칼라의 Vector
기반으로 구현되어 있는데 이게 **퍼시스턴트 자료 구조**라고 해서 복사 비용이 O(1)이면서도
불변성을 유지할 수가 있어요. 뭔 소린지 모르겠다면 예제를 보자 맨이야.

```python
a = ['R', 'V', 'E', 'L', 'O']
b = a
b[0] = 'L' # b를 수정했는데 a가 같이 수정된다맨

c = a[:]
c[0] = 'K' # 이제 c를 수정하면 a가 수정되지 않는 대신 시간복잡도가 O(n)이다맨
```

```scala
import mte._
import scala.language.postfixOps

아니세상에 자기가 "뭉" 이라는사람인데 한줄서기(7, 7, 4)를 했대
아니세상에 자기가 "탱" 이라는사람인데 ("뭉" 갖고와 0 할게 한판마안~~!! 5)를 했대
"뭉" 리액션 "%s\n"
"탱" 리액션 "%s\n" // 탱 을 수정해도 뭉 은 그대로 유지되고, 시간복잡도 O(1)이다맨
```

각설하고 문법은 대충 이렇게 생겼어요~

```scala
import mte._
import scala.language.postfixOps

// list(9, 1, 3)을 정의 후 변수 "뭉"에 대입
아니세상에 자기가 "뭉" 이라는사람인데 한줄서기(9, 1, 3)를 했대

// 0이 100개 있는 한줄서기를 정의 후 변수 "뭉"에 대입
아니세상에 자기가 "뭉" 이라는사람인데 왕한줄서기(100, 0)를 했대

// 0, 1, 2, ..., 9가 든 한줄서기를 정의 후 변수 "뭉"에 대입
아니세상에 자기가 "뭉" 이라는사람인데 (뭐 드시냐고 10 번째 물어봅니다)를 했대

// 연결하기
한줄서기(9, 1) 조이는 한줄서기(3) // [9, 1, 3]

// 자르기
한줄서기(1, 9, 8, 3, 0, 1, 3, 1) ㄸㄸㅆ 3 // [1, 9, 8, 3, 0]
```

한줄서기는 함수형 프로그래밍의 기본인 map과 filter를 제공한다 맨이야.

```scala
import mte._
import scala.language.postfixOps

// 각 원소를 2배씩 늘린 새로운 리스트 만들기
한줄서기(6, 0, 9) 즐기면서가자 ("뭉"은 ("뭉" 조이고 2)다 게이조이고)

// [0, 1, 2, ..., 9]에서 3의 배수가 아닌 수만 남기기
뭐 드시냐고 10 번째 물어봅니다 씻구 ("뭉"은 ("뭉" 코가커요 3 꼽표~~)다 게이조이고)
// 또는
뭐 드시냐고 10 번째 물어봅니다 특수한 ("뭉"은 ("뭉" 코가커요 3)이다 게이조이고)
```

